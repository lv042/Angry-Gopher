package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	log "github.com/sirupsen/logrus"
	"io"
	"net/http"
	"net/http/httptest"
	"reflect"
	"testing"
	"time"
)

var jwtToken string

func init() {

	go func() { // Initialize the test server
		main()
	}()
	time.Sleep(3 * time.Second) // Wait for the server to start

	eraseAllData()
	generateFakeData()

	var err error
	jwtToken, err = GenerateToken("testing", 0, 1*time.Hour)
	log.Info("JWT Token: ", jwtToken)
	if err != nil {
		log.Fatal("Failed to generate JWT token: ", err)
	}

}

func TestRegister(t *testing.T) {
	// Prepare the test request body
	requestBody := SystemInfo{
		Hostname:     "TestDevice",
		OS:           "Linux",
		Architecture: "x86_64",
	}
	requestBodyJSON, err := json.Marshal(requestBody)
	if err != nil {
		t.Fatalf("Failed to marshal request body: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/register", bytes.NewReader(requestBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]int8
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the response contains the expected "id" field
	if _, ok := responseBody["id"]; !ok {
		t.Fatalf("Response JSON does not contain \"id\" field")
	}

	var expected int8 = 3
	if responseBody["id"] != expected {
		t.Fatalf("Expected id %d but got %d", expected, responseBody["id"])
	}
}

func TestPing(t *testing.T) {
	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/ping/1", nil)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the response contains the expected "message" field
	if _, ok := responseBody["message"]; !ok {
		t.Fatalf("Response JSON does not contain \"message\" field")
	}

	expected := "Pong!"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestGetCommandList(t *testing.T) {
	// Assuming there are at least two devices with command lists generated in the fake data
	// Fetch the command list for the first device (index 0) for simplicity
	deviceIndex := 0

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/cmd/%d", devices[deviceIndex].ID), nil)
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var commandResults []CommandResult
	err = json.NewDecoder(res.Body).Decode(&commandResults)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the number of command results in the response matches the expected count
	expectedCommandCount := 3 // As per the example, there are three commands generated by generateFakeData
	if len(commandResults) != expectedCommandCount {
		t.Fatalf("Expected %d command results, but got %d", expectedCommandCount, len(commandResults))
	}

	// Define the expected commands based on the generated fake data
	expectedCommands := []CommandResult{
		{
			Command:      "ls -a",
			Response:     "Not yet executed",
			ID:           1,
			TimeOpened:   devices[deviceIndex].CommandList[0].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[0].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[0].Dir,
			Executed:     false,
			Tries:        0,
		},
		{
			Command:      "ls",
			Response:     "Not yet executed",
			ID:           2,
			TimeOpened:   devices[deviceIndex].CommandList[1].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[1].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[1].Dir,
			Executed:     false,
			Tries:        0,
		},
		{
			Command:      "pwd",
			Response:     "Not yet executed",
			ID:           3,
			TimeOpened:   devices[deviceIndex].CommandList[2].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[2].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[2].Dir,
			Executed:     false,
			Tries:        0,
		},
	}
	// Check if the response contains the expected command results
	for i, expectedCmd := range expectedCommands {
		if !compareCommandResults(expectedCmd, commandResults[i]) {
			//show the difference
			log.Info("Expected: ", expectedCmd)
			log.Info("Got: ", commandResults[i])
			t.Fatalf("Command result with ID %d does not match the expected command result", expectedCmd.ID)
		}
	}
}

func compareCommandResults(expected, actual CommandResult) bool {
	// If the time fields are equal, set them to zero time to compare as nil
	if expected.TimeOpened.UTC().Equal(actual.TimeOpened.UTC()) {
		expected.TimeOpened = time.Time{}
		actual.TimeOpened = time.Time{}
	}

	if expected.TimeExecuted.UTC().Equal(actual.TimeExecuted.UTC()) {
		expected.TimeExecuted = time.Time{}
		actual.TimeExecuted = time.Time{}
	}

	// Perform the deep equal comparison after setting time fields to zero time
	return reflect.DeepEqual(expected, actual)
}

func TestUpdateCommandResult(t *testing.T) {
	// Prepare the test request body
	updatedCommandResult := CommandResult{
		ID:           1,
		Command:      "Updated command",
		Response:     "Updated message",
		TimeOpened:   time.Now(),
		TimeExecuted: time.Now(),
		Dir:          "/updated/directory",
		Executed:     true,
	}
	updatedBodyJSON, err := json.Marshal(updatedCommandResult)
	if err != nil {
		t.Fatalf("Failed to marshal updated command result: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/cmd/1", bytes.NewReader(updatedBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	expected := "Command result updated successfully"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestGetInstructionList(t *testing.T) {
	// Assuming there are at least two devices with instruction lists generated in the fake data
	// Fetch the instruction list for the first device (index 0) for simplicity
	deviceIndex := 0

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/ins/%d", devices[deviceIndex].ID), nil)
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var instructionResults []InstructionResult
	err = json.NewDecoder(res.Body).Decode(&instructionResults)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the number of instruction results in the response matches the expected count
	expectedInstructionCount := 3 // As per the example, there are three instructions generated by generateFakeData
	if len(instructionResults) != expectedInstructionCount {
		t.Fatalf("Expected %d instruction results, but got %d", expectedInstructionCount, len(instructionResults))
	}

	// Define the expected instructions based on the generated fake data
	expectedInstructions := []InstructionResult{
		{
			Instruction:  "install",
			Response:     "Not yet executed",
			ID:           1,
			TimeOpened:   devices[deviceIndex].InstructionList[0].TimeOpened,
			TimeExecuted: devices[deviceIndex].InstructionList[0].TimeExecuted,
			Dir:          devices[deviceIndex].InstructionList[0].Dir,
			Executed:     false,
			Tries:        0,
		},
		{
			Instruction:  "update",
			Response:     "Not yet executed",
			ID:           2,
			TimeOpened:   devices[deviceIndex].InstructionList[1].TimeOpened,
			TimeExecuted: devices[deviceIndex].InstructionList[1].TimeExecuted,
			Dir:          devices[deviceIndex].InstructionList[1].Dir,
			Executed:     false,
			Tries:        0,
		},
		{
			Instruction:  "uninstall",
			Response:     "Not yet executed",
			ID:           3,
			TimeOpened:   devices[deviceIndex].InstructionList[2].TimeOpened,
			TimeExecuted: devices[deviceIndex].InstructionList[2].TimeExecuted,
			Dir:          devices[deviceIndex].InstructionList[2].Dir,
			Executed:     false,
			Tries:        0,
		},
	}
	// Check if the response contains the expected instruction results
	for i, expectedInst := range expectedInstructions {
		if !compareInstructionResults(expectedInst, instructionResults[i]) {
			t.Fatalf("Instruction result with ID %d does not match the expected instruction result", expectedInst.ID)
		}
	}
}

func compareInstructionResults(expected, actual InstructionResult) bool {
	// If the time fields are equal, set them to zero time to compare as nil
	if expected.TimeOpened.UTC().Equal(actual.TimeOpened.UTC()) {
		expected.TimeOpened = time.Time{}
		actual.TimeOpened = time.Time{}
	}

	if expected.TimeExecuted.UTC().Equal(actual.TimeExecuted.UTC()) {
		expected.TimeExecuted = time.Time{}
		actual.TimeExecuted = time.Time{}
	}

	// Perform the deep equal comparison after setting time fields to zero time
	return reflect.DeepEqual(expected, actual)
}

func TestUpdateInstructionResult(t *testing.T) {
	// Prepare the test request body
	updatedInstructionResult := InstructionResult{
		ID:           1,
		Instruction:  "Updated instruction",
		Response:     "Updated response",
		TimeOpened:   time.Now(),
		TimeExecuted: time.Now(),
		Dir:          "/updated/directory",
		Executed:     true,
	}
	updatedBodyJSON, err := json.Marshal(updatedInstructionResult)
	if err != nil {
		t.Fatalf("Failed to marshal updated instruction result: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/ins/1", bytes.NewReader(updatedBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	expected := "Instruction result updated successfully"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestCheckVersion(t *testing.T) {
	// Prepare the test request body
	requestBody := struct {
		Version string `json:"version"`
	}{Version: "0.0.1"}
	requestBodyJSON, err := json.Marshal(requestBody)
	if err != nil {
		t.Fatalf("Failed to marshal request body: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodGet, "/version", bytes.NewReader(requestBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	expected := "You are on the newest version"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestGenerateFakeData(t *testing.T) {
	// Initialize the test data
	generateFakeData()

	// Check if the devices slice is not empty
	if len(devices) == 0 {
		t.Fatal("Devices slice is empty")
	}

	// Check each device in the devices slice
	for i, device := range devices {
		// Check the device ID
		expectedID := int8(i + 1)
		if device.ID != expectedID {
			t.Fatalf("Device ID does not match expected value. Expected: %d, Got: %d", expectedID, device.ID)
		}

		// Check the system info
		expectedHostname := fmt.Sprintf("Device%d", i+1)
		if device.SystemInfo.Hostname != expectedHostname {
			t.Fatalf("Device hostname does not match expected value. Expected: %s, Got: %s", expectedHostname, device.SystemInfo.Hostname)
		}

		// Check the command list for the device
		expectedCommands := []string{"ls -a", "ls", "pwd"}
		if len(device.CommandList) != len(expectedCommands) {
			t.Fatalf("Number of commands for device does not match expected value. Expected: %d, Got: %d", len(expectedCommands), len(device.CommandList))
		}

		for j, commandResult := range device.CommandList {
			if commandResult.Command != expectedCommands[j] {
				t.Fatalf("Command message does not match expected value. Expected: %s, Got: %s", expectedCommands[j], commandResult.Command)
			}

			if commandResult.ID != int8(j+1) {
				t.Fatalf("Command ID does not match expected value. Expected: %d, Got: %d", j+1, commandResult.ID)
			}

			// We can't compare the TimeOpened directly, but we can check if it's not a zero time
			if commandResult.TimeOpened.IsZero() {
				t.Fatalf("Command TimeOpened is zero")
			}

			// TimeExecuted should be zero time since it is not yet executed
			if !commandResult.TimeExecuted.IsZero() {
				t.Fatalf("Command TimeExecuted is not zero")
			}

			if commandResult.Dir != "Not yet executed" {
				t.Fatalf("Command Dir does not match expected value. Expected: %s, Got: %s", "Not yet executed", commandResult.Dir)
			}

			// Executed should be randomly set to true or false by generateFakeData
			if commandResult.Executed != true && commandResult.Executed != false {
				t.Fatalf("Command Executed is not a boolean value")
			}
		}
	}
}

func TestGenerateToken_InvalidInput(t *testing.T) {
	// Test generating token with an empty username
	token, err := GenerateToken("", 0, 1*time.Hour)
	if err == nil {
		t.Fatalf("Expected error but go,t nil")
	}
	if token != "" {
		t.Fatalf("Expected empty token but got %s", token)
	}
}

func TestVerifyToken_ExpiredToken(t *testing.T) {
	expiredToken, err := GenerateToken("test_user", 0, 1*time.Nanosecond)

	//wait to expire
	time.Sleep(500 * time.Millisecond)
	if err != nil {
		t.Fatalf("Failed to generate expired token: %v", err)
	}

	// Verify the expired token
	valid := VerifyToken(expiredToken)
	if valid {
		t.Fatal("Expired token verification should have failed")
	}
}

func TestVerifyToken_TamperedToken(t *testing.T) {
	// Generate a valid token for testing
	validToken, err := GenerateToken("test_user", 0, 10*time.Minute)
	if err != nil {
		t.Fatalf("Failed to generate valid token: %v", err)
	}

	// Tamper with the token by appending some random data
	tamperedToken := validToken + "random_data"

	// Verify the tampered token
	valid := VerifyToken(tamperedToken)
	if valid {
		t.Fatal("Tampered token verification should have failed")
	}
}

func TestAuthMiddleware_NoToken(t *testing.T) {
	// Create a new test request and response recorder without a token
	req := httptest.NewRequest(http.MethodGet, "/devices", nil)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusUnauthorized {
		t.Fatalf("Expected status code %d but got %d", http.StatusUnauthorized, res.StatusCode)
	}
}

func TestAuthMiddleware_ExpiredToken(t *testing.T) {
	// Generate an expired token with a very short expiration time for testing
	expiredToken, err := GenerateToken("test_user", 0, 1*time.Nanosecond)
	if err != nil {
		t.Fatalf("Failed to generate expired token: %v", err)
	}

	// Create a new test request and response recorder with the expired token
	req := httptest.NewRequest(http.MethodGet, "/devices", nil)
	req.Header.Set("Authorization", "Bearer "+expiredToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusUnauthorized {
		t.Fatalf("Expected status code %d but got %d", http.StatusUnauthorized, res.StatusCode)
	}
}

func TestAuthMiddleware_TamperedToken(t *testing.T) {
	// Generate a valid token for testing
	validToken, err := GenerateToken("test_user", 0, 10*time.Minute)
	if err != nil {
		t.Fatalf("Failed to generate valid token: %v", err)
	}

	// Tamper with the token by appending some random data
	tamperedToken := validToken + "random_data"

	// Create a new test request and response recorder with the tampered token
	req := httptest.NewRequest(http.MethodGet, "/devices", nil)
	req.Header.Set("Authorization", "Bearer "+tamperedToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusUnauthorized {
		t.Fatalf("Expected status code %d but got %d", http.StatusUnauthorized, res.StatusCode)
	}
}
