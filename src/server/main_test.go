package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"
)

var jwtToken string

func init() {
	go func() { // Initialize the test server
		main()
	}()

	//generate token
	setupDotenv()
	var err error
	jwtToken, err = GenerateToken("testing")
	if err != nil {
		panic(err)
	}

}

func TestRegister(t *testing.T) {
	// Prepare the test request body
	requestBody := SystemInfo{
		Hostname:     "TestDevice",
		OS:           "Linux",
		Architecture: "x86_64",
	}
	requestBodyJSON, err := json.Marshal(requestBody)
	if err != nil {
		t.Fatalf("Failed to marshal request body: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/register", bytes.NewReader(requestBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]int8
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the response contains the expected "id" field
	if _, ok := responseBody["id"]; !ok {
		t.Fatalf("Response JSON does not contain \"id\" field")
	}

	var expected int8 = 3
	if responseBody["id"] != expected {
		t.Fatalf("Expected id %d but got %d", expected, responseBody["id"])
	}
}

func TestPing(t *testing.T) {
	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/ping/1", nil)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the response contains the expected "message" field
	if _, ok := responseBody["message"]; !ok {
		t.Fatalf("Response JSON does not contain \"message\" field")
	}

	expected := "Pong!"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestGetCommandList(t *testing.T) {
	// Assuming there are at least two devices with command lists generated in the fake data
	// Fetch the command list for the first device (index 0) for simplicity
	deviceIndex := 0

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodGet, fmt.Sprintf("/cmd/%d", devices[deviceIndex].ID), nil)
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var commandResults []CommandResult
	err = json.NewDecoder(res.Body).Decode(&commandResults)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	// Check if the number of command results in the response matches the expected count
	expectedCommandCount := 3 // As per the example, there are three commands generated by generateFakeData
	if len(commandResults) != expectedCommandCount {
		t.Fatalf("Expected %d command results, but got %d", expectedCommandCount, len(commandResults))
	}

	// Define the expected commands based on the generated fake data
	expectedCommands := []CommandResult{
		{
			Message:      "ls -a",
			ID:           1,
			TimeOpened:   devices[deviceIndex].CommandList[0].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[0].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[0].Dir,
			Executed:     false,
		},
		{
			Message:      "ls",
			ID:           2,
			TimeOpened:   devices[deviceIndex].CommandList[1].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[1].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[1].Dir,
			Executed:     false,
		},
		{
			Message:      "pwd",
			ID:           3,
			TimeOpened:   devices[deviceIndex].CommandList[2].TimeOpened,
			TimeExecuted: devices[deviceIndex].CommandList[2].TimeExecuted,
			Dir:          devices[deviceIndex].CommandList[2].Dir,
			Executed:     false,
		},
	}

	// Check if the response contains the expected command results
	for i, expectedCmd := range expectedCommands {
		if !compareCommandResults(expectedCmd, commandResults[i]) {
			t.Fatalf("Command result with ID %d does not match the expected command result", expectedCmd.ID)
		}
	}
}

func compareCommandResults(expected, actual CommandResult) bool {
	return expected.Message == actual.Message &&
		expected.ID == actual.ID &&
		expected.TimeOpened.Equal(actual.TimeOpened) &&
		expected.TimeExecuted.Equal(actual.TimeExecuted) &&
		expected.Dir == actual.Dir &&
		expected.Executed == actual.Executed
}

func TestUpdateCommandResult(t *testing.T) {
	// Prepare the test request body
	updatedCommandResult := CommandResult{
		ID:           1,
		Message:      "Updated message",
		TimeOpened:   time.Now(),
		TimeExecuted: time.Now(),
		Dir:          "/updated/directory",
		Executed:     true,
	}
	updatedBodyJSON, err := json.Marshal(updatedCommandResult)
	if err != nil {
		t.Fatalf("Failed to marshal updated command result: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodPost, "/cmd/1", bytes.NewReader(updatedBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	expected := "Command result updated successfully"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

//func TestGetInstructionList(t *testing.T) {
//	// Create a new test request and response recorder
//	req := httptest.NewRequest(http.MethodGet, "/ins/1", nil)
//	req.Header.Set("Authorization", "Bearer "+jwt_token)
//	res, err := app.Test(req)
//	if err != nil {
//		t.Fatalf("Failed to perform test request: %v", err)
//	}
//	defer func(Body io.ReadCloser) {
//		err := Body.Close()
//		if err != nil {
//			t.Fatalf("Failed to close response body: %v", err)
//		}
//	}(res.Body)
//
//	// Check the response status code
//	if res.StatusCode != http.StatusOK {
//		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
//	}
//
//	// Parse the response JSON
//	var instructionList InstructionList
//	err = json.NewDecoder(res.Body).Decode(&instructionList)
//	if err != nil {
//		t.Fatalf("Failed to parse response JSON: %v", err)
//	}
//
//	// Assuming there are some instructions in the device at index 0
//	if len(instructionList.Instructions) == 0 {
//		t.Fatalf("Expected non-empty instruction list, but got an empty list")
//	}
//}

func TestCheckVersion(t *testing.T) {
	// Prepare the test request body
	requestBody := struct {
		Version string `json:"version"`
	}{Version: "0.0.1"}
	requestBodyJSON, err := json.Marshal(requestBody)
	if err != nil {
		t.Fatalf("Failed to marshal request body: %v", err)
	}

	// Create a new test request and response recorder
	req := httptest.NewRequest(http.MethodGet, "/version", bytes.NewReader(requestBodyJSON))
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+jwtToken)
	res, err := app.Test(req)
	if err != nil {
		t.Fatalf("Failed to perform test request: %v", err)
	}
	defer func(Body io.ReadCloser) {
		err := Body.Close()
		if err != nil {
			t.Fatalf("Failed to close response body: %v", err)
		}
	}(res.Body)

	// Check the response status code
	if res.StatusCode != http.StatusOK {
		t.Fatalf("Expected status code %d but got %d", http.StatusOK, res.StatusCode)
	}

	// Parse the response JSON
	var responseBody map[string]string
	err = json.NewDecoder(res.Body).Decode(&responseBody)
	if err != nil {
		t.Fatalf("Failed to parse response JSON: %v", err)
	}

	expected := "You are on the newest version"
	if responseBody["message"] != expected {
		t.Fatalf("Expected message %s but got %s", expected, responseBody["message"])
	}
}

func TestGenerateFakeData(t *testing.T) {
	// Initialize the test data
	generateFakeData()

	// Check if the devices slice is not empty
	if len(devices) == 0 {
		t.Fatal("Devices slice is empty")
	}

	// Check each device in the devices slice
	for i, device := range devices {
		// Check the device ID
		expectedID := int8(i + 1)
		if device.ID != expectedID {
			t.Fatalf("Device ID does not match expected value. Expected: %d, Got: %d", expectedID, device.ID)
		}

		// Check the system info
		expectedHostname := fmt.Sprintf("Device%d", i+1)
		if device.SystemInfo.Hostname != expectedHostname {
			t.Fatalf("Device hostname does not match expected value. Expected: %s, Got: %s", expectedHostname, device.SystemInfo.Hostname)
		}

		// Check the command list for the device
		expectedCommands := []string{"ls -a", "ls", "pwd"}
		if len(device.CommandList) != len(expectedCommands) {
			t.Fatalf("Number of commands for device does not match expected value. Expected: %d, Got: %d", len(expectedCommands), len(device.CommandList))
		}

		for j, commandResult := range device.CommandList {
			if commandResult.Message != expectedCommands[j] {
				t.Fatalf("Command message does not match expected value. Expected: %s, Got: %s", expectedCommands[j], commandResult.Message)
			}

			if commandResult.ID != int8(j+1) {
				t.Fatalf("Command ID does not match expected value. Expected: %d, Got: %d", j+1, commandResult.ID)
			}

			// We can't compare the TimeOpened directly, but we can check if it's not a zero time
			if commandResult.TimeOpened.IsZero() {
				t.Fatalf("Command TimeOpened is zero")
			}

			// TimeExecuted should be zero time since it is not yet executed
			if !commandResult.TimeExecuted.IsZero() {
				t.Fatalf("Command TimeExecuted is not zero")
			}

			if commandResult.Dir != "Not yet executed" {
				t.Fatalf("Command Dir does not match expected value. Expected: %s, Got: %s", "Not yet executed", commandResult.Dir)
			}

			// Executed should be randomly set to true or false by generateFakeData
			if commandResult.Executed != true && commandResult.Executed != false {
				t.Fatalf("Command Executed is not a boolean value")
			}
		}
	}
}
